{"version":3,"sources":["src/assets/js/kavenegar-voice.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA,gDAAgD,+BAA+B;AAC/E;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,2DAA2D;AAC3D;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sBAAsB;;AAErF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2GAA2G,8BAA8B,MAAM,0BAA0B;AACzK;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wEAAwE,YAAY,MAAM,OAAO;AACjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc,KAAK,UAAU,KAAK,IAAI,KAAK,QAAQ,IAAI,UAAU;AACpG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc,KAAK,UAAU,KAAK,IAAI,KAAK,QAAQ,IAAI,UAAU;AACpG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,E","file":"scripts.js","sourcesContent":["const JoinStatus = {\n    SUCCESS: 'success',\n    SDK_VERSION_NOT_SUPPORTED: 'sdk_version_not_supported',\n    ACCESS_DENIED: 'access_denied',\n    INVALID_CALL: 'invalid_call',\n    CALL_SESSION_FINISHED: 'call_session_finished',\n    FAILED_TO_CONNECT: 'failed_to_connect',\n    UNKNOWN_ERROR: 'unknown_error'\n};\nconst CallStatus = {\n    NEW: 'new',\n    TRYING: 'trying',\n    RINGING: 'ringing',\n    ACCEPTED: 'accepted',\n    CONVERSATION: 'conversation',\n    PAUSED: 'paused',\n    FINISHED: 'finished',\n    FLUSHED: 'flushed'\n};\n\nconst CallDirection = {\n    INBOUND: 'inbound',\n    OUTBOUND: 'outbound'\n};\nconst CallFinishedReason = {\n    HANGUP: 'hangup',\n    UNREACHABLE: 'unreachable',\n    MISSED: 'missed',\n    REJECTED: 'rejected',\n    KILLED: 'killed',\n    CALL_RECEIVED: 'call_received',\n    MEDIA_CONNECTION_BROKEN: 'media_connection_broken',\n    MESSAGING_CONNECTION_BROKEN: 'messaging_connection_broken',\n    BUSY: 'busy',\n    CALL_DURATION_EXCEEDED: 'call_duration_exceeded',\n    UNKNOWN: 'unknown'\n};\n\nconst EndpointRole = {\n    CALLER: 'caller', RECEPTOR: 'receptor'\n};\n\nconst Environment = {\n    TEST: 'wss://messaging.dev.kavenegar.io/v1',\n    DEVELOPMENT: 'ws://192.168.1.188:8080/v1',\n    PRODUCTION: 'wss://messaging.kavenegar.io/v1'\n};\n\nconst MediaState = {\n    CONNECTED: 'connected', DISCONNECTED: 'disconnected'\n};\n\nconst MessagingStatus = {\n    INITIALIZED: 'initialized',\n    DISCONNECTED: 'disconnected', // connection closed ( not manually )\n    TERMINATED: 'terminated', // connection terminated manually\n    CONNECTED: 'connected', // CONNECTED to messaging server\n    JOINED: 'joined', // CONNECTED to messaging server and authorized successfully\n    FAILED: 'failed' // FAILED to connect or authorize to messaging server\n};\n\nconst LogLevel = {\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARN: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    toString(level) {\n        for (const prop in LogLevel) {\n            if (LogLevel[prop] === level) return prop;\n        }\n        return null;\n    }\n};\n\n\nfunction Queue() {\n    var queue = [];\n    var offset = 0;\n\n    this.getLength = function () {\n        return (queue.length - offset);\n    };\n\n    this.isEmpty = function () {\n        return (queue.length === 0);\n    };\n\n    this.enqueue = function (item) {\n        queue.push(item);\n    };\n\n\n    this.remove = function () {\n        var packet = this.dequeue();\n    };\n    this.dequeue = function () {\n        if (queue.length === 0) return undefined;\n        var item = queue[offset];\n        if (++offset * 2 >= queue.length) {\n            queue = queue.slice(offset);\n            offset = 0;\n        }\n        return item;\n\n    };\n    this.peek = function () {\n        return (queue.length > 0 ? queue[offset] : undefined);\n    };\n\n\n    this.clear = function () {\n        queue = [];\n    };\n\n\n    this.toString = function () {\n        return JSON.stringify(queue);\n    }\n\n}\n\nclass KavenegarCall {\n\n    constructor(environment) {\n        this.className = this.constructor.name;\n        this.environment = environment;\n        this.calls = [];\n\n    }\n\n    initCall(params, callback) {\n        if (this.getCallById(params.callId) != null) {\n            callback(\"error\", \"duplicate_call_id\");\n            return;\n        }\n\n        const self = this;\n\n        if (params.logger === undefined || params.logger === null) params.logger = new Logger(LogLevel.INFO);\n\n        const call = new Call(params.callId, params.logger,params.localStream,params.remoteElement, this.environment);\n\n\n        call.intervalId = setInterval(() => {\n            if (call.status === CallStatus.FLUSHED) {\n                clearInterval(call.intervalId);\n                this.close(call);\n            } else {\n                call.run.bind(call).call(null);\n            }\n        }, 10);\n\n\n        call.messaging.start(call.id, params.accessToken,  (joinResponse) => {\n            if (joinResponse.result !== JoinStatus.SUCCESS) {\n                callback(joinResponse.result, null);\n                return;\n            }\n            call.caller = joinResponse.caller;\n            call.receptor = joinResponse.receptor;\n            call.direction = joinResponse.direction;\n            callback(joinResponse.result, call);\n\n            self.calls.push(call);\n        });\n    };\n\n    close(call) {\n        var indexOf = this.calls.indexOf(call);\n        if (indexOf < 0) {\n            return;\n        }\n        this.calls.splice(indexOf, 1);\n    }\n\n    getCallById(callId) {\n        for (let i = 0; i < this.calls.length; i++) {\n            const call = this.calls[i];\n            if (call.id === callId) return call;\n        }\n        return null;\n    };\n\n    getActiveCall() {\n        for (let i = 0; i < this.calls.length; i++) {\n            const call = this.calls[i];\n            if (call.status !== CallStatus.FINISHED) return call;\n        }\n        return null;\n    }\n\n}\n\n\nclass KavenegarMedia {\n\n    constructor(logger) {\n        this.className = \"media\";\n        this.logger = logger;\n        this.connection = null;\n        this.onStateChanged = null;\n\n        this.offerOptions = {\n            offerToReceiveAudio: 1,\n            offerToReceiveVideo: 0,\n            voiceActivityDetection: false\n        };\n    }\n\n\n    hasUserMedia() {\n        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||\n            navigator.mozGetUserMedia);\n    };\n\n    start(stream, remoteElement) {\n\n        const configuration = {\n            iceServers: [{\"urls\": \"stun:stun.1.google.com:19302\"}],\n            rtcpMuxPolicy: \"require\",\n            iceTransportPolicy: \"all\"\n        };\n\n        const connection = new RTCPeerConnection(configuration);\n        this.connection = connection;\n        this.stream = stream;\n        this.logger.info(this.className, \"RTCPeerConnection object was created\");\n\n\n        connection.addStream(stream);\n\n\n        connection.onaddstream = function (e) {\n            remoteElement.srcObject = e.stream;\n            remoteElement.play();\n        };\n\n        connection.onicecandidate = (event) => {\n            if (event.candidate) {\n                this.logger.info(this.className, \"ice candidate found\", JSON.stringify(event));\n            }\n        };\n    };\n\n\n    get status() {\n        return {\n            \"iceGatheringState : \": this.connection.iceGatheringState,\n            \"iceConnectionState\": this.connection.iceConnectionState,\n            \"signalingState\": this.connection.signalingState\n        };\n    };\n\n    makeOffer(callback) {\n        this.connection.onicegatheringstatechange = (state) => {\n            this.logger.info(this.className, \"onicegatheringstatechange\", state.toString());\n            if (this.connection.iceGatheringState === \"complete\") {\n                callback(this.connection.localDescription);\n            }\n        };\n        this.connection.oniceconnectionstatechange = (state) => {\n            this.logger.info(this.className, \"oniceconnectionstatechange\", state.toString());\n        };\n\n        this.connection.onsignalingstatechange = (state) => {\n            this.logger.info(this.className, \"onsignalingstatechange\", state.toString());\n        };\n\n        this.connection.createOffer(this.offerOptions).then((offer) => {\n            this.logger.info(this.className, \"offer created\" + offer.toString());\n            this.connection.setLocalDescription(offer);\n        }, (error) => {\n            this.logger.error(this.className, \"error in createOffer \", error);\n        });\n    };\n\n    setAnswer(answerSdp) {\n        var answer = new RTCSessionDescription({type: \"answer\", sdp: answerSdp});\n        this.connection.setRemoteDescription(answer).then(() => {\n            this.logger.info(this.className, \"set answer was success\");\n        }).catch(reason => {\n            this.logger.error(this.className, \"set answer has error\", reason);\n        });\n    };\n\n    addIceCandidate(candidate) {\n        try {\n            this.connection.addIceCandidate(new RTCIceCandidate({\n                candidate: candidate.candidate,\n                sdpMLineIndex: candidate.sdpLineIndex,\n                sdpMid: candidate.sdpMin\n            }));\n        } catch (e) {\n            this.logger.error(this.className, \"Error in addIceCandidate\", e);\n        }\n    };\n\n    dispose() {\n        let tracks = this.stream.getTracks();\n\n        tracks.forEach(function (track) {\n            track.stop();\n        });\n\n        this.connection.close();\n    };\n\n}\n\n\nclass Packet {\n    constructor(action) {\n        this.action = action;\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n}\n\nclass JoinRequest extends Packet {\n    constructor(callId, accessToken, sdkVersion) {\n        super(\"join\");\n        this.apiToken = accessToken;\n        this.sdkVersion = sdkVersion;\n        this.deviceName = 'Desktop';\n        this.deviceCPU = 'x64';\n        this.osVersion = 11;\n        this.callId = callId;\n        this.supportedABI = \"any\";\n    }\n}\n\n\nclass JoinResponse extends Packet {\n\n    constructor(result, call) {\n        super(\"join.response\");\n        if (call === undefined) call = null;\n        this.result = result;\n        this.call = call;\n    }\n}\n\n\nclass CallResponse extends Packet {\n    constructor(callId, status) {\n        super(\"call.response\");\n        this.status = status;\n    }\n}\n\nclass AckRequest extends Packet {\n\n    constructor(id) {\n        super(\"ack\");\n        this.id = id;\n    }\n}\n\nclass OfferRequest extends Packet {\n    constructor(callId, sdp) {\n        super(\"offer\");\n        this.sdp = sdp;\n    }\n}\n\nclass ByeRequest extends Packet {\n    constructor(callId, reason) {\n        super(\"bye\");\n        this.reason = reason;\n    }\n}\n\nclass IceCandidateRequest extends Packet {\n    constructor(callId, candidate) {\n        super(\"call.ice_candidate\");\n        this.candidate = candidate;\n    }\n}\n\nclass PingRequest extends Packet {\n    constructor(id) {\n        super(\"ping\");\n        this.id = id;\n    }\n}\n\nclass PongRequest extends Packet {\n    constructor(id) {\n        super(\"pong\");\n        this.id = id;\n    }\n}\n\nclass KavenegarMessaging {\n\n\n    constructor(environment, call, logger) {\n        this.className = \"messaging\";\n        this.session = null;\n        this.queue = new Queue();\n        this._status = MessagingStatus.INITIALIZED;\n        this.call = call;\n        this.loginResponseListener = null;\n        this.reconnectTry = 0;\n        this.accessToken = \"\";\n        this.environment = environment;\n        this.logger = logger;\n        this.closeTry = 0;\n        this.lastHearbeatTime = new Date();\n        this.lastPongPacket = false;\n        this.onStatusChanged = function (status) {\n        };\n    }\n\n\n    check() {\n        if (this.session == null || this.status === MessagingStatus.TERMINATED || this.status === MessagingStatus.INITIALIZED || this.status === MessagingStatus.DISCONNECTED || this.status === MessagingStatus.FAILED) {\n            return;\n        }\n\n        try {\n            const packet = this.queue.peek();\n            if (packet === undefined) {\n                this.checkHeartbeat();\n                return;\n            }\n            if (packet.id === undefined || packet.id == null) {\n                packet.id = this.makeId(7);\n            }\n            if (packet.sent) {\n                const diffInMs = new Date() - packet.sentAt;\n                if (diffInMs > 2000) {\n                    packet.sent = false;\n                    this.logger.warn(this.className, \"Packet ack is not received going to resend : \" + packet.toString())\n                } else {\n                    return;\n                }\n            }\n\n            let raw = JSON.stringify(packet);\n            this.logger.info(this.className, \"Send Packet :\" + raw);\n            this.session.send(raw);\n            packet.sent = true;\n            packet.sentAt = new Date();\n        } catch (ex) {\n            this.logger.error(this.className, \"Error in check\", ex);\n        }\n\n    };\n\n    checkHeartbeat() {\n        if (this.status !== MessagingStatus.JOINED) return; // dont send ping in joined\n        if (new Date() - this.lastHearbeatTime > 5000) {\n            this.lastHearbeatTime = new Date(); // must be dismis for duplciating close function\n            if (!this.lastPongPacket) {\n                this.logger.info(this.className, \"Heartbeat ack is not received, going to close websocket\");\n                this.session.onclose();\n                return;\n            }\n            const packet = new PingRequest(this.makeId(7));\n            this.session.send(JSON.stringify(packet));\n            this.logger.debug(this.className, \"Send Ping Request: \" + packet);\n            this.lastPongPacket = false;\n        }\n    }\n\n    start(callId, accessToken, callback) {\n        this.accessToken = accessToken;\n        this.session = new WebSocket(this.environment);\n\n        this.session.onerror = (error) => {\n            this.logger.error(this.className, \"websocket error : \", error);\n        };\n\n        this.session.onopen = (event) => {\n            this.lastPongPacket = true;\n            this.status = MessagingStatus.CONNECTED;\n            this.send(new JoinRequest(callId, accessToken, 1));\n            this.loginResponseListener = (response) => {\n                if (response !== JoinStatus.SUCCESS) {\n                    this.status = MessagingStatus.JOINED;\n                    callback(response);\n                } else {\n                    this.status = MessagingStatus.FAILED;\n                    callback(response);\n                }\n            };\n            this.session.onclose = (event) => {\n                this.onClosed();\n            };\n        };\n\n        this.session.onmessage = (event) => {\n            this.handleMessage(JSON.parse(event.data));\n        };\n\n        this.session.onclose = (error) => {\n            this.logger.info(this.className, \"websocket closed : \", error);\n            callback(new JoinResponse(JoinStatus.FAILED_TO_CONNECT));\n        };\n    };\n\n    send(packet) {\n        packet.id = null;\n        this.queue.enqueue(packet);\n    };\n\n\n    onClosed() {\n        this.reconnect();\n    };\n\n\n    reconnect() {\n        try {\n            if (this.status === MessagingStatus.CONNECTED || this.status === MessagingStatus.JOINED) this.status = MessagingStatus.DISCONNECTED;\n            if (this.status !== MessagingStatus.DISCONNECTED) return;\n\n            if (this.reconnectTry >= 30) {\n                this.logger.info(this.className, \"Can't connect to server after many tryings ...\");\n                this.status = MessagingStatus.FAILED;\n                this.call.onFinished(CallFinishedReason.MESSAGING_CONNECTION_BROKEN);\n                return;\n            }\n\n            this.reconnectTry++;\n            const self = this;\n            this.logger.info(this.className, \"Trying to connect to messaging server : #\" + this.reconnectTry);\n            this.start(this.call.id, this.accessToken, (response) => {\n                this.logger.info(this.className, \"Reconnect result :\" + response);\n                switch (response.result) {\n                    case JoinStatus.SUCCESS: {\n                        this.reconnectTry = 0;\n                        break;\n                    }\n                    case JoinStatus.FAILED_TO_CONNECT: {\n                        this.status = MessagingStatus.DISCONNECTED;\n                        setTimeout(function () {\n                            self.reconnect();\n                        }.bind(self), 500);\n                        break;\n                    }\n                    case JoinStatus.CALL_SESSION_FINISHED : {\n                        this.queue.clear();\n                        break;\n                    }\n                    default: {\n                        this.queue.clear();\n                        this.call.onFinished(CallFinishedReason.MESSAGING_CONNECTION_BROKEN);\n                        this.status = MessagingStatus.FAILED;\n                    }\n                }\n            });\n\n        } catch (e) {\n\n        }\n    };\n\n    handleMessage(message) {\n\n        if (this.isNeedToLog(message)) {\n            this.logger.info(this.className, \"onMessage => \" + JSON.stringify(message));\n        }\n\n        if (this.isNeedToAck(message)) {\n            this.logger.debug(this.className, \"Send Ack for => \" + JSON.stringify(message));\n            this.session.send(JSON.stringify(new AckRequest(message.id)));\n        }\n\n        switch (message.action) {\n            case \"ack\": {\n                this.onAck(message);\n                break;\n            }\n            case \"join.response\" : {\n                this.handleJoinResponse(message);\n                break;\n            }\n            case \"make_offer\" : {\n                this.onMakeOffer(message);\n                break;\n            }\n            case \"call.response\" : {\n                this.onCallResponse(message);\n                break;\n            }\n            case \"media_status\" : {\n                this.onMediaStatus(message);\n                break;\n            }\n            case \"call.ice_candidate\" : {\n                this.onIceCandidate(message);\n                break;\n            }\n            case \"answer\" : {\n                this.onAnswer(message);\n                break;\n            }\n            case \"bye\" : {\n                this.onBye(message);\n                break;\n            }\n            case \"ping\" : {\n                this.onPing(message);\n                break;\n            }\n            case \"pong\" : {\n                this.onPong(message);\n                break;\n            }\n        }\n    };\n\n    isNeedToLog(payload) {\n        const action = payload.action;\n        return action !== \"ack\" && action !== \"ping\" && action !== \"pong\";\n    }\n\n    isNeedToAck(payload) {\n        const action = payload.action;\n        return action !== \"ack\" && action !== \"ping\" && action !== \"pong\" && payload.id !== undefined && payload.id !== null;\n    };\n\n    onPing(message) {\n        const packet = new PongRequest(message.id);\n        this.session.send(JSON.stringify(packet));\n    };\n\n    onPong(message) {\n        this.lastPongPacket = true;\n    };\n\n    onAck(payload) {\n        try {\n            const id = payload.id;\n            const packet = this.queue.peek();\n            if (packet == null) {\n                return;\n            }\n\n            if (packet.id === id) {\n                this.logger.debug(this.className, \"Ack packet received remove packet from queue =\" + JSON.stringify(packet));\n                this.queue.remove();\n            } else {\n                this.logger.warn(this.className, \"Can't find ack packet : \" + payload.id + \" , must be : \" + packet.toString());\n            }\n\n        } catch (e) {\n            this.logger.error(this.className, \"Error in handle ack request\", e);\n        }\n    };\n\n    onMakeOffer() {\n        this.call.initMedia();\n        this.call.media.makeOffer((offer) => {\n            this.send(new OfferRequest(this.call.id, offer.sdp));\n        });\n    };\n\n    onIceCandidate(payload) {\n        this.call.media.addIceCandidate(payload);\n    };\n\n    onAnswer(payload) {\n        this.call.media.setAnswer(payload.sdp);\n    };\n\n    onBye(payload) {\n        this.call.status = CallStatus.FINISHED;\n        if (this.call.onFinished) {\n            this.call.onFinished(payload.reason);\n        }\n\n    };\n\n    onCallResponse(payload) {\n        this.call.status = payload.status;\n        if (payload.status === CallStatus.FINISHED) {\n            this.call.status = CallStatus.FINISHED;\n            this.call.onFinished(CallFinishedReason.UNKNOWN);\n        }\n    };\n\n    onMediaStatus(payload) {\n        const currentStatus = {caller: this.call.callerMediaStatus, receptor: this.call.receptorMediaStatus};\n        const newStatus = {\n            caller: payload.caller ? MediaState.CONNECTED : MediaState.DISCONNECTED,\n            receptor: payload.receptor ? MediaState.CONNECTED : MediaState.DISCONNECTED\n        };\n\n        if (currentStatus.caller !== newStatus.caller) {\n            this.call.callerMediaStatus = newStatus.caller;\n            const event = {\n                oldState: currentStatus.caller,\n                newState: newStatus.caller,\n                role: 'caller'\n            };\n            this.logger.info(this.className, `onMediaStatus [${JSON.stringify(event)}] , `);\n\n            this.call.onMediaStateChanged(event);\n        } else if (currentStatus.receptor !== newStatus.receptor) {\n            this.call.receptorMediaStatus = newStatus.receptor;\n            const event = {\n                oldState: currentStatus.receptor,\n                newState: newStatus.receptor,\n                role: 'receptor'\n            };\n            this.logger.info(this.className, \"onMediaStatus [\" + JSON.stringify(event) + \"]\");\n            this.call.onMediaStateChanged(event);\n        } else {\n            this.logger.warn(this.className, `onMediaStatus => is not belong to caller or receptor !!! , ${JSON.stringify(currentStatus)} => ${JSON.stringify(newStatus)} `);\n        }\n    };\n\n    handleJoinResponse(payload) {\n        if (this.loginResponseListener) {\n            this.loginResponseListener(payload);\n        }\n    };\n\n    makeId(length) {\n        let result = '';\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        const charactersLength = characters.length;\n        for (let i = 0; i < length; i++) {\n            result += characters.charAt(Math.floor(Math.random() * charactersLength));\n        }\n        return result;\n    };\n\n    get status() {\n        return this._status;\n    }\n\n    set status(status) {\n        if (this._status === status) return;\n        if (this.onStatusChanged != null) {\n            this.logger.info(\"StateChangedListener called => old : \" + this.status + \" , new : \" + status);\n            this.onStatusChanged(this._status, status);\n        }\n        this._status = status;\n    };\n\n\n    close(callback) {\n        if (!this.queue.isEmpty()) {\n            this.logger.warn(this.className, \"Queue is not empty , there is : \" + this.queue.toString());\n        }\n\n        if (!this.queue.isEmpty() && this.closeTry < 20) {\n            return setTimeout(() => {\n                this.closeTry++;\n                this.close(callback);\n            }, 1000);\n        }\n\n        if (!this.queue.isEmpty()) {\n            this.logger.error(this.className, \"Queue is killed with some messages : \" + this.queue.toString());\n            this.queue.clear();\n        }\n\n        this.status = MessagingStatus.TERMINATED;\n        this.reconnectTry = 0; // we must reset counter after trying for next time in call\n\n        try {\n            if (this.session != null) {\n                this.session.close();\n                this.session = null;\n            }\n            callback(true);\n        } catch (ex) {\n            this.logger.error(this.className, \"Error in close WebSocket\", ex);\n            callback(false);\n        }\n    };\n\n}\n\n\nclass Call {\n\n    constructor(id, logger, localStream, remoteElement, environment) {\n        this.className = \"call\";\n        this.id = id;\n        this._status = CallStatus.NEW;\n\n        this.logger = logger;\n\n        this.messaging = new KavenegarMessaging(environment, this, logger);\n        this.media = null;\n\n        this.callerMediaStatus = MediaState.DISCONNECTED;\n        this.receptorMediaStatus = MediaState.DISCONNECTED;\n        this.duration = 0;\n        this.lastComputedDuration = 0;\n        this.stream = localStream;\n        this.element = remoteElement;\n\n\n        this.onStatusChanged = () => {\n        };\n\n        this.onFinished = () => {\n        };\n\n        this.onMediaStateChanged = () => {\n        };\n\n        this.onMessagingStateChanged = () => {\n        };\n    }\n\n\n    initMedia() {\n\n        if (this.media != null) {\n            this.media.dispose();\n            this.media = null;\n        }\n\n        this.media = new KavenegarMedia(this.logger);\n        this.media.start(this.stream, this.element)\n    };\n\n\n    hangup(reason) {\n        if (reason === undefined) reason = \"hangup\";\n        if (this.status === CallStatus.FINISHED || this.status === CallStatus.FLUSHED) {\n            throw new Error(\"Call already finished, \" + this.toString());\n        }\n        this.messaging.send(new ByeRequest(this.id, reason));\n        this.status = CallStatus.FINISHED;\n        this.onFinished(reason);\n    };\n\n    accept() {\n        if (this.direction === CallDirection.OUTBOUND) {\n            throw new Error(\"You can't accept an outbound call, \" + this.toString());\n        }\n\n        this.messaging.send(new CallResponse(this.id, CallStatus.ACCEPTED));\n        this.status = CallStatus.ACCEPTED;\n    };\n\n    ringing() {\n        if (this.status !== CallStatus.NEW && this.status !== CallStatus.TRYING) {\n            throw new Error(\"Only call this method on trying state, \" + this.toString());\n        }\n        this.messaging.send(new CallResponse(this.id, CallStatus.RINGING));\n        this.status = CallStatus.RINGING;\n    };\n\n    reject() {\n        if (this.status !== CallStatus.RINGING || this.direction === CallDirection.OUTBOUND) {\n            throw new Error(\"Only call this method on ringing state or must be have inbound call ,\" + this.toString());\n        }\n        this.messaging.send(new ByeRequest(this.id, CallFinishedReason.REJECTED));\n        this.onFinished(CallFinishedReason.REJECTED);\n    };\n\n\n    get status() {\n        return this._status;\n    }\n\n    set status(status) {\n\n        if (this.status !== status && this.onStatusChanged != null) {\n            this.onStatusChanged(status);\n        }\n\n        if (this.startedAt != null && status === CallStatus.CONVERSATION) {\n            this.startedAt = new Date();\n        }\n\n        if (this.finishedAt != null && status === CallStatus.FINISHED) {\n            this.finishedAt = new Date();\n        }\n\n        this.logger.info(this.className, `Call status is changed from ${this.status} => ${status}`);\n        this._status = status;\n    };\n\n    computeDuration() {\n        if (this.lastComputedDuration !== 0 && this.status === CallStatus.CONVERSATION) {\n            const diff = Math.round(Date.now() - this.lastComputedDuration);\n            this.duration += diff;\n        }\n        this.lastComputedDuration = Date.now();\n    };\n\n    run() {\n        this.computeDuration();\n        this.messaging.check();\n    };\n\n    dispose() {\n        this.messaging.close(() => {\n            if (this.media !== null) {\n                this.media.dispose();\n                this.media = null;\n            }\n            if (this.logger != null && this.logger.className === \"RemoteLogger\") {\n                this.logger.dispose();\n            }\n            this.status = CallStatus.FLUSHED;\n        });\n    };\n\n\n    toString() {\n        return \"#\" + this.id + \" , status=\" + (this.status == null ? \"null\" : this.status.toString()) + \", direction=\" + this.direction.toString();\n    }\n}\nclass Logger {\n\n    constructor(level) {\n        this.className = \"DefaultLogger\";\n        this.level = level;\n    }\n\n    isLoggable(level) {\n        return this.level <= level;\n    }\n\n    log(level, tag, message, throwable) {\n        if (this.isLoggable(level)) {\n            const now = new Date();\n            let formattedDate = now.getFullYear() + \"-\" + (now.getMonth() + 1) + \"-\" + now.getDate() + \" \" + now.getHours() + \":\" + now.getMinutes() + \":\" + now.getSeconds() + \".\" + now.getMilliseconds();\n            if (throwable !== undefined) throwable = JSON.stringify(throwable);\n            if (throwable === undefined) throwable = \"\";\n            const levelName = LogLevel.toString(level).toString().toLowerCase();\n            console[levelName](`[${formattedDate}] [${levelName}] [${tag}] [${message}] ${throwable}`)\n        }\n    }\n\n    debug(tag, message, throwable) {\n        this.log(LogLevel.DEBUG, tag, message, throwable);\n    }\n\n    verbose(tag, message, throwable) {\n        this.log(LogLevel.VERBOSE, tag, message, throwable);\n    }\n\n    info(tag, message, throwable) {\n        this.log(LogLevel.INFO, tag, message, throwable);\n    }\n\n    warn(tag, message, throwable) {\n        this.log(LogLevel.WARN, tag, message, throwable);\n    }\n\n    error(tag, message, throwable) {\n        this.log(LogLevel.ERROR, tag, message, throwable);\n    }\n}\n\nclass RemoteLogger extends Logger {\n\n    constructor(level, callId, accessToken, environment) {\n        super(level);\n        this.className = \"RemoteLogger\";\n        this.callId = callId;\n        this.accessToken = accessToken;\n        this.environment = environment;\n        this.queue = new Queue();\n\n        if (environment == null) environment = Environment.PRODUCTION;\n\n        switch (environment) {\n            case Environment.DEVELOPMENT:\n                this.url = \"ws://127.0.0.1:8080/logger/\" + callId + \"/\" + accessToken;\n                break;\n            case Environment.TEST:\n                this.url = \"wss://messaging.dev.kavenegar.io/logger/\" + callId + \"/\" + accessToken;\n                break;\n            case Environment.PRODUCTION:\n                this.url = \"wss://messaging.kavenegar.io/logger/\" + callId + \"/\" + accessToken;\n                break;\n        }\n\n        this.status = RemoteLoggerConnectionStatus.NEW;\n        this.intervalId = setInterval(this.run.bind(this), 2000);\n    }\n\n\n    connect() {\n        this.websocket = new WebSocket(this.url);\n        this.status = RemoteLoggerConnectionStatus.TRYING;\n\n        this.websocket.onerror = (error) => {\n        };\n\n        this.websocket.onopen = (event) => {\n            this.status = RemoteLoggerConnectionStatus.CONNECTED;\n        };\n\n        this.websocket.onmessage = (event) => {\n        };\n\n        this.websocket.onclose = (error) => {\n            if (this.status !== RemoteLoggerConnectionStatus.FINISHED) {\n                this.status = RemoteLoggerConnectionStatus.CLOSED;\n            }\n        };\n    }\n\n    run() {\n        if (this.queue.isEmpty()) return;\n\n        if (this.status === RemoteLoggerConnectionStatus.FINISHED) {\n            this.dispose();\n            return;\n        }\n        if (this.status === RemoteLoggerConnectionStatus.CLOSED || this.status === RemoteLoggerConnectionStatus.NEW) {\n            this.connect();\n            return;\n        }\n\n        let packets = [];\n        for (let i = 0; i < this.queue.getLength(); i++) {\n            packets.push(this.queue.dequeue());\n        }\n\n        try {\n            this.websocket.send(JSON.stringify(packets));\n        } catch (e) {\n            this.queue.enqueue(packets);\n        }\n\n    }\n\n    dispose() {\n        if (this.intervalId != null) {\n            if (!this.queue.isEmpty()) {\n                console.error(\"Logger is doing to dispose with data \", this.queue.toString());\n            }\n            clearInterval(this.intervalId);\n            this.websocket.close();\n            this.intervalId = null;\n            this.status = RemoteLoggerConnectionStatus.FINISHED;\n        }\n    }\n\n    isLoggable(level) {\n        return this.level <= level;\n    }\n\n    log(level, tag, message, throwable) {\n        if (this.isLoggable(level)) {\n            const now = new Date();\n            let formattedDate = now.getFullYear() + \"-\" + (now.getMonth() + 1) + \"-\" + now.getDate() + \" \" + now.getHours() + \":\" + now.getMinutes() + \":\" + now.getSeconds() + \".\" + now.getMilliseconds();\n            if (throwable !== undefined) throwable = JSON.stringify(throwable);\n            if (throwable === undefined) throwable = \"\";\n            const levelName = LogLevel.toString(level).toString().toLowerCase();\n            this.queue.enqueue(`[${formattedDate}] [${levelName}] [${tag}] [${message}] ${throwable}`);\n        }\n    }\n\n    debug(tag, message, throwable) {\n        this.log(LogLevel.DEBUG, tag, message, throwable);\n    }\n\n    verbose(tag, message, throwable) {\n        this.log(LogLevel.VERBOSE, tag, message, throwable);\n    }\n\n    info(tag, message, throwable) {\n        this.log(LogLevel.INFO, tag, message, throwable);\n    }\n\n    warn(tag, message, throwable) {\n        this.log(LogLevel.WARN, tag, message, throwable);\n    }\n\n    error(tag, message, throwable) {\n        this.log(LogLevel.ERROR, tag, message, throwable);\n    }\n\n}\n\nconst RemoteLoggerConnectionStatus = {\n    CONNECTED: 'connected',\n    FINISHED: 'finished',\n    CLOSED: 'closed',\n    TRYING: 'trying',\n    NEW: 'new'\n};"],"sourceRoot":"webpack:///"}